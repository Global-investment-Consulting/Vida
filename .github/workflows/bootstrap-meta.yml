name: Bootstrap Repo Meta

on:
  push:
    branches:
      - main

jobs:
  bootstrap-meta:
    if: vars.META_BOOTSTRAPPED != 'true' && hashFiles('.github/bootstrap-meta.sentinel') == ''
    runs-on: ubuntu-latest
    permissions:
      actions: write
      issues: write
      contents: write
      metadata: read
    steps:
      - name: Seed repository metadata
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const core = require('@actions/core');
            const { owner, repo } = context.repo;

            const milestoneTitles = [
              'M1 Monorepo & Validator',
              'M2 Peppol Live',
              'M3 Italy SDI (Mock)',
              'M4 France PDP (Mock)',
              'M5 PL/HU/ES (Mocked)',
              'M6 Routing/API/Plugins',
              'M7 Hardening & Docs'
            ];

            const labelDefinitions = [
              { name: 'feature', color: '0366d6', description: 'Feature work' },
              { name: 'adapter', color: '1f883d', description: 'Adapter implementations' },
              { name: 'validator', color: '8a2be2', description: 'Validator and schema updates' },
              { name: 'plugin', color: 'a371f7', description: 'Plugin development' },
              { name: 'infra', color: 'd73a4a', description: 'Infrastructure and tooling' }
            ];

            const issueTitle = 'Repo settings checklist';
            const issueBody = [
              '- [ ] Enable Auto-merge in repo settings',
              '- [ ] Protect `main`: require PR + checks (`build-test`, `fixtures-matrix`, `e2e-smoke`) and up-to-date branches'
            ].join('\n');

            // Ensure milestones exist
            const existingMilestones = await github.paginate(github.rest.issues.listMilestones, {
              owner,
              repo,
              state: 'all'
            });
            for (const title of milestoneTitles) {
              const alreadyExists = existingMilestones.some((milestone) => milestone.title === title);
              if (!alreadyExists) {
                core.info(`Creating milestone "${title}"`);
                await github.rest.issues.createMilestone({ owner, repo, title });
              } else {
                core.info(`Milestone "${title}" already exists`);
              }
            }

            // Ensure labels exist (update colors/descriptions if necessary)
            const existingLabels = await github.paginate(github.rest.issues.listLabelsForRepo, {
              owner,
              repo
            });
            for (const label of labelDefinitions) {
              const current = existingLabels.find((existing) => existing.name.toLowerCase() === label.name.toLowerCase());
              if (!current) {
                core.info(`Creating label "${label.name}"`);
                await github.rest.issues.createLabel({ owner, repo, ...label });
              } else {
                const needsUpdate =
                  current.color.toLowerCase() !== label.color.toLowerCase() ||
                  (label.description || '') !== (current.description || '');
                if (needsUpdate) {
                  core.info(`Updating label "${label.name}"`);
                  await github.rest.issues.updateLabel({
                    owner,
                    repo,
                    name: current.name,
                    new_name: label.name,
                    color: label.color,
                    description: label.description
                  });
                } else {
                  core.info(`Label "${label.name}" already up to date`);
                }
              }
            }

            // Ensure the checklist issue exists
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'all'
            });
            const checklistIssue = issues.find((issue) => !issue.pull_request && issue.title === issueTitle);
            if (!checklistIssue) {
              core.info(`Creating issue "${issueTitle}"`);
              await github.rest.issues.create({
                owner,
                repo,
                title: issueTitle,
                body: issueBody,
                labels: ['infra'],
                assignees: ['samgoetz']
              });
            } else {
              core.info(`Issue "${issueTitle}" already exists (#${checklistIssue.number})`);
            }

            // Ensure sentinel file exists (allows guard before variable update propagates)
            const sentinelPath = '.github/bootstrap-meta.sentinel';
            let sentinelSha = undefined;
            try {
              const existingSentinel = await github.rest.repos.getContent({
                owner,
                repo,
                path: sentinelPath
              });
              if (!Array.isArray(existingSentinel.data) && existingSentinel.data.type === 'file') {
                sentinelSha = existingSentinel.data.sha;
              }
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }
            const sentinelContent = Buffer.from(`bootstrapped=${new Date().toISOString()}\n`).toString('base64');
            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: sentinelPath,
              message: 'chore: mark metadata bootstrap complete',
              content: sentinelContent,
              sha: sentinelSha,
              committer: {
                name: 'github-actions[bot]',
                email: '41898282+github-actions[bot]@users.noreply.github.com'
              },
              author: {
                name: 'github-actions[bot]',
                email: '41898282+github-actions[bot]@users.noreply.github.com'
              }
            });

            // Create or update repository variable to disable further runs
            const variableName = 'META_BOOTSTRAPPED';
            try {
              core.info(`Creating repository variable "${variableName}"`);
              await github.request('POST /repos/{owner}/{repo}/actions/variables', {
                owner,
                repo,
                name: variableName,
                value: 'true'
              });
            } catch (error) {
              if (error.status === 409) {
                core.info(`Repository variable "${variableName}" already exists, updating value`);
                await github.request('PATCH /repos/{owner}/{repo}/actions/variables/{name}', {
                  owner,
                  repo,
                  name: variableName,
                  value: 'true'
                });
              } else {
                throw error;
              }
            }
