name: Scrada Integration

on:
  push:
    branches:
      - main
      - feat/scrada-e2e-clean
  workflow_dispatch:
    inputs:
      run_ref:
        description: "Git ref to run (default feat/scrada-e2e-clean)"
        required: false
        default: "feat/scrada-e2e-clean"

jobs:
  scrada:
    runs-on: ubuntu-latest
    env:
      VIDA_AP_ADAPTER: scrada
      SCRADA_API_KEY: ${{ secrets.SCRADA_API_KEY }}
      SCRADA_API_PASSWORD: ${{ secrets.SCRADA_API_PASSWORD }}
      SCRADA_COMPANY_ID: ${{ secrets.SCRADA_COMPANY_ID }}
      SCRADA_WEBHOOK_SECRET: ${{ secrets.SCRADA_WEBHOOK_SECRET }}
      SCRADA_API_BASE: ${{ vars.SCRADA_API_BASE }}
      SCRADA_LANGUAGE: ${{ vars.SCRADA_LANGUAGE }}
      SCRADA_TEST_RECEIVER_SCHEME: ${{ vars.SCRADA_TEST_RECEIVER_SCHEME }}
      SCRADA_TEST_RECEIVER_ID: ${{ vars.SCRADA_TEST_RECEIVER_ID }}
      SCRADA_SUPPLIER_SCHEME: ${{ vars.SCRADA_SUPPLIER_SCHEME }}
      SCRADA_SUPPLIER_ID: ${{ vars.SCRADA_SUPPLIER_ID }}
      SCRADA_SUPPLIER_VAT: ${{ vars.SCRADA_SUPPLIER_VAT }}
      SCRADA_RECEIVER_VAT: ${{ vars.SCRADA_RECEIVER_VAT }}
      SCRADA_SKIP_PARTICIPANT_PREFLIGHT: ${{ vars.SCRADA_SKIP_PARTICIPANT_PREFLIGHT }}
      SCRADA_PARTICIPANT_ID: ${{ format('{0}:{1}', vars.SCRADA_TEST_RECEIVER_SCHEME, vars.SCRADA_TEST_RECEIVER_ID) }}
      ARCHIVE_BUCKET: ${{ vars.ARCHIVE_BUCKET }}
      SCRADA_HEADER_SWEEP: "true"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run_ref || github.ref }}

      - name: Use Node.js 20.19
        uses: actions/setup-node@v4
        with:
          node-version: "20.19.0"
          cache: "npm"

      - name: Mask Scrada secrets
        run: |
          echo "::add-mask::${SCRADA_API_KEY}"
          echo "::add-mask::${SCRADA_API_PASSWORD}"
          echo "::add-mask::${SCRADA_COMPANY_ID}"
          echo "::add-mask::${SCRADA_WEBHOOK_SECRET}"

      - name: Verify adapter
        shell: bash
        run: |
          echo "Adapter=${VIDA_AP_ADAPTER}"
          [ "${VIDA_AP_ADAPTER}" = "scrada" ] || (echo "::error::Unexpected adapter"; exit 1)
          echo "ADAPTER_CHECK=Adapter=${VIDA_AP_ADAPTER}" >> "$GITHUB_ENV"

      - name: Isolation check (no Billit vars)
        shell: bash
        run: |
          LEAKS=$(env | awk -F= '/^BILLIT_/ {print $1}')
          if [ -z "$LEAKS" ]; then
            echo "Isolation=OK"
            echo "ISOLATION_RESULT=Isolation=OK" >> "$GITHUB_ENV"
          else
            echo "::error::$LEAKS"
            exit 1
          fi

      - name: env-presence (VAR=OK)
        shell: bash
        run: |
          set -euo pipefail
          required_vars=(
            VIDA_AP_ADAPTER
            SCRADA_API_KEY
            SCRADA_API_PASSWORD
            SCRADA_COMPANY_ID
            SCRADA_API_BASE
            SCRADA_LANGUAGE
            SCRADA_TEST_RECEIVER_SCHEME
            SCRADA_TEST_RECEIVER_ID
            SCRADA_SUPPLIER_SCHEME
            SCRADA_SUPPLIER_ID
            SCRADA_SUPPLIER_VAT
            SCRADA_RECEIVER_VAT
          )
          missing=0
          for var in "${required_vars[@]}"; do
            if [ -z "${!var:-}" ]; then
              echo "::error::Missing required environment variable $var"
              missing=1
            else
              echo "${var}=OK"
            fi
          done
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - run: rm -rf apps/api/node_modules apps/api/dist
        shell: bash

      - run: npm ci --workspaces || (npm ci && (cd apps/api && npm install --no-audit --no-fund))
        shell: bash

      - run: npm run build --workspaces || (npm run build && (cd apps/api && npm run build))
        shell: bash

      - name: Show revision
        shell: bash
        run: |
          echo "Adapter=${VIDA_AP_ADAPTER}"
          echo "REF=${GITHUB_REF}"
          echo "SHA=${GITHUB_SHA}"
          git rev-parse HEAD
      - name: Run unit tests
        shell: bash
        run: |
          set -euo pipefail
          npm test -- --run apps/api/tests/scrada.*

      - name: Configure Scrada pass 0208
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p artifacts/scrada
          echo "SCRADA_TEST_RECEIVER_SCHEME=0208" >> "$GITHUB_ENV"
          echo "SCRADA_TEST_RECEIVER_ID=${SCRADA_SUPPLIER_ID}" >> "$GITHUB_ENV"
          echo "SCRADA_PARTICIPANT_ID=0208:${SCRADA_SUPPLIER_ID}" >> "$GITHUB_ENV"
          echo "SCRADA_ARTIFACT_DIR=artifacts/scrada/0208" >> "$GITHUB_ENV"
          echo "ReceiverPass=0208" >> "$GITHUB_ENV"
          echo "Configured receiver pass 0208"

      - name: Wait for Scrada participant readiness (0208)
        if: ${{ env.SCRADA_SKIP_PARTICIPANT_PREFLIGHT != 'true' && env.SCRADA_SKIP_PARTICIPANT_PREFLIGHT != 'TRUE' }}
        id: scrada_participant_0208
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${SCRADA_ARTIFACT_DIR}"
          node apps/api/scripts/scrada-wait-participant.mjs --participant "${SCRADA_PARTICIPANT_ID}" > "${SCRADA_ARTIFACT_DIR}/participant.json"
          cat "${SCRADA_ARTIFACT_DIR}/participant.json"

      - name: Scrada smoke send (0208)
        id: scrada_send_0208
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${SCRADA_ARTIFACT_DIR}"
          send_log="${SCRADA_ARTIFACT_DIR}/scrada-send-output.log"
          send_json="${SCRADA_ARTIFACT_DIR}/scrada-send-output.json"
          rm -f "${send_log}" "${send_json}"
          set +e
          node apps/api/scripts/scrada-send.mjs --artifact-dir "${SCRADA_ARTIFACT_DIR}" --vat "${SCRADA_RECEIVER_VAT}" > "${send_log}" 2>&1
          send_exit=$?
          set -e
          cat "${send_log}"
          node - <<'NODE' "${send_log}" "${send_json}"
            const fs = require("fs");
            const [logPath, jsonPath] = process.argv.slice(2);
            if (!fs.existsSync(logPath)) {
              process.exit(0);
            }
            const text = fs.readFileSync(logPath, "utf8");
            for (let idx = text.length - 1; idx >= 0; idx -= 1) {
              if (text[idx] !== "{") {
                continue;
              }
              try {
                const data = JSON.parse(text.slice(idx));
                fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2));
                break;
              } catch (error) {
                continue;
              }
            }
          NODE
          send_status="failure"
          document_id=""
          invoice_id=""
          external_reference=""
          send_channel=""
          vat_variant=""
          if [ -f "${send_json}" ] && jq -e '.success == true' "${send_json}" >/dev/null 2>&1; then
            send_status="success"
            document_id=$(jq -r '.documentId' "${send_json}")
            invoice_id=$(jq -r '.invoiceId' "${send_json}")
            external_reference=$(jq -r '.externalReference' "${send_json}")
            send_channel=$(jq -r '.channel' "${send_json}")
            vat_variant=$(jq -r '.vatVariant' "${send_json}")
            jq '.' "${send_json}"
          else
            if [ -f "${send_json}" ]; then
              jq '.' "${send_json}" || true
            fi
          fi
          echo "send_status=${send_status}" >> "$GITHUB_OUTPUT"
          echo "send_exit=${send_exit}" >> "$GITHUB_OUTPUT"
          echo "document_id=${document_id}" >> "$GITHUB_OUTPUT"
          echo "invoice_id=${invoice_id}" >> "$GITHUB_OUTPUT"
          echo "external_reference=${external_reference}" >> "$GITHUB_OUTPUT"
          echo "send_channel=${send_channel}" >> "$GITHUB_OUTPUT"
          echo "vat_variant=${vat_variant}" >> "$GITHUB_OUTPUT"
          if [ "${send_status}" != "success" ]; then
            echo "Scrada send (0208) did not complete successfully (exit=${send_exit})." >&2
          fi

      - name: Poll Scrada status and archive (0208)
        id: scrada_status_0208
        if: ${{ steps.scrada_send_0208.outputs.send_status == 'success' }}
        shell: bash
        run: |
          set -euo pipefail
          node apps/api/scripts/scrada-status.mjs "${{ steps.scrada_send_0208.outputs.document_id }}" --archive > "${SCRADA_ARTIFACT_DIR}/scrada-status.log"
          cat "${SCRADA_ARTIFACT_DIR}/scrada-status.log"
          jq -s '.' "${SCRADA_ARTIFACT_DIR}/scrada-status.log" > "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json"
          cat "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json"
          status=$(jq -r '.[0].status' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          classification=$(jq -r '.[0].classification' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          archive_driver=$(jq -r '.[1].driver // empty' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          archive_location=$(jq -r '.[1].location // empty' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          archive_key=$(jq -r '.[1].key // empty' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          echo "status=${status}" >> "$GITHUB_OUTPUT"
          echo "classification=${classification}" >> "$GITHUB_OUTPUT"
          echo "archive_driver=${archive_driver}" >> "$GITHUB_OUTPUT"
          echo "archive_location=${archive_location}" >> "$GITHUB_OUTPUT"
          echo "archive_key=${archive_key}" >> "$GITHUB_OUTPUT"

      - name: Configure Scrada pass 9925
        shell: bash
        run: |
          set -euo pipefail
          echo "SCRADA_TEST_RECEIVER_SCHEME=9925" >> "$GITHUB_ENV"
          echo "SCRADA_TEST_RECEIVER_ID=${SCRADA_RECEIVER_VAT}" >> "$GITHUB_ENV"
          echo "SCRADA_PARTICIPANT_ID=9925:${SCRADA_RECEIVER_VAT}" >> "$GITHUB_ENV"
          echo "SCRADA_ARTIFACT_DIR=artifacts/scrada/9925" >> "$GITHUB_ENV"
          echo "ReceiverPass=9925" >> "$GITHUB_ENV"
          echo "Configured receiver pass 9925"

      - name: Wait for Scrada participant readiness (9925)
        if: ${{ env.SCRADA_SKIP_PARTICIPANT_PREFLIGHT != 'true' && env.SCRADA_SKIP_PARTICIPANT_PREFLIGHT != 'TRUE' }}
        id: scrada_participant_9925
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${SCRADA_ARTIFACT_DIR}"
          node apps/api/scripts/scrada-wait-participant.mjs --participant "${SCRADA_PARTICIPANT_ID}" > "${SCRADA_ARTIFACT_DIR}/participant.json"
          cat "${SCRADA_ARTIFACT_DIR}/participant.json"

      - name: Scrada smoke send (9925)
        id: scrada_send_9925
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${SCRADA_ARTIFACT_DIR}"
          send_log="${SCRADA_ARTIFACT_DIR}/scrada-send-output.log"
          send_json="${SCRADA_ARTIFACT_DIR}/scrada-send-output.json"
          rm -f "${send_log}" "${send_json}"
          set +e
          node apps/api/scripts/scrada-send.mjs --artifact-dir "${SCRADA_ARTIFACT_DIR}" --vat "${SCRADA_RECEIVER_VAT}" > "${send_log}" 2>&1
          send_exit=$?
          set -e
          cat "${send_log}"
          node - <<'NODE' "${send_log}" "${send_json}"
            const fs = require("fs");
            const [logPath, jsonPath] = process.argv.slice(2);
            if (!fs.existsSync(logPath)) {
              process.exit(0);
            }
            const text = fs.readFileSync(logPath, "utf8");
            for (let idx = text.length - 1; idx >= 0; idx -= 1) {
              if (text[idx] !== "{") {
                continue;
              }
              try {
                const data = JSON.parse(text.slice(idx));
                fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2));
                break;
              } catch (error) {
                continue;
              }
            }
          NODE
          send_status="failure"
          document_id=""
          invoice_id=""
          external_reference=""
          send_channel=""
          vat_variant=""
          if [ -f "${send_json}" ] && jq -e '.success == true' "${send_json}" >/dev/null 2>&1; then
            send_status="success"
            document_id=$(jq -r '.documentId' "${send_json}")
            invoice_id=$(jq -r '.invoiceId' "${send_json}")
            external_reference=$(jq -r '.externalReference' "${send_json}")
            send_channel=$(jq -r '.channel' "${send_json}")
            vat_variant=$(jq -r '.vatVariant' "${send_json}")
            jq '.' "${send_json}"
          else
            if [ -f "${send_json}" ]; then
              jq '.' "${send_json}" || true
            fi
          fi
          echo "send_status=${send_status}" >> "$GITHUB_OUTPUT"
          echo "send_exit=${send_exit}" >> "$GITHUB_OUTPUT"
          echo "document_id=${document_id}" >> "$GITHUB_OUTPUT"
          echo "invoice_id=${invoice_id}" >> "$GITHUB_OUTPUT"
          echo "external_reference=${external_reference}" >> "$GITHUB_OUTPUT"
          echo "send_channel=${send_channel}" >> "$GITHUB_OUTPUT"
          echo "vat_variant=${vat_variant}" >> "$GITHUB_OUTPUT"
          if [ "${send_status}" != "success" ]; then
            echo "Scrada send (9925) did not complete successfully (exit=${send_exit})." >&2
          fi

      - name: Poll Scrada status and archive (9925)
        id: scrada_status_9925
        if: ${{ steps.scrada_send_9925.outputs.send_status == 'success' }}
        shell: bash
        run: |
          set -euo pipefail
          node apps/api/scripts/scrada-status.mjs "${{ steps.scrada_send_9925.outputs.document_id }}" --archive > "${SCRADA_ARTIFACT_DIR}/scrada-status.log"
          cat "${SCRADA_ARTIFACT_DIR}/scrada-status.log"
          jq -s '.' "${SCRADA_ARTIFACT_DIR}/scrada-status.log" > "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json"
          cat "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json"
          status=$(jq -r '.[0].status' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          classification=$(jq -r '.[0].classification' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          archive_driver=$(jq -r '.[1].driver // empty' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          archive_location=$(jq -r '.[1].location // empty' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          archive_key=$(jq -r '.[1].key // empty' "${SCRADA_ARTIFACT_DIR}/scrada-status-output.json")
          echo "status=${status}" >> "$GITHUB_OUTPUT"
          echo "classification=${classification}" >> "$GITHUB_OUTPUT"
          echo "archive_driver=${archive_driver}" >> "$GITHUB_OUTPUT"
          echo "archive_location=${archive_location}" >> "$GITHUB_OUTPUT"
          echo "archive_key=${archive_key}" >> "$GITHUB_OUTPUT"

      - name: Assemble Scrada summary
        if: always()
        shell: bash
        env:
          RUN_URL: ${{ format('https://github.com/{0}/actions/runs/{1}', github.repository, github.run_id) }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          ISOLATION_RESULT: ${{ env.ISOLATION_RESULT }}
          ADAPTER_CHECK: ${{ env.ADAPTER_CHECK }}
          PASS0208_STATUS: ${{ steps.scrada_send_0208.outputs.send_status }}
          PASS0208_CHANNEL: ${{ steps.scrada_send_0208.outputs.send_channel }}
          PASS0208_EXIT: ${{ steps.scrada_send_0208.outputs.send_exit }}
          PASS0208_DOCUMENT_ID: ${{ steps.scrada_send_0208.outputs.document_id }}
          PASS0208_INVOICE_ID: ${{ steps.scrada_send_0208.outputs.invoice_id }}
          PASS0208_EXTERNAL_REFERENCE: ${{ steps.scrada_send_0208.outputs.external_reference }}
          PASS0208_VAT_VARIANT: ${{ steps.scrada_send_0208.outputs.vat_variant }}
          PASS0208_ARCHIVE_DRIVER: ${{ steps.scrada_status_0208.outputs.archive_driver }}
          PASS0208_ARCHIVE_LOCATION: ${{ steps.scrada_status_0208.outputs.archive_location }}
          PASS0208_ARCHIVE_KEY: ${{ steps.scrada_status_0208.outputs.archive_key }}
          PASS9925_STATUS: ${{ steps.scrada_send_9925.outputs.send_status }}
          PASS9925_CHANNEL: ${{ steps.scrada_send_9925.outputs.send_channel }}
          PASS9925_EXIT: ${{ steps.scrada_send_9925.outputs.send_exit }}
          PASS9925_DOCUMENT_ID: ${{ steps.scrada_send_9925.outputs.document_id }}
          PASS9925_INVOICE_ID: ${{ steps.scrada_send_9925.outputs.invoice_id }}
          PASS9925_EXTERNAL_REFERENCE: ${{ steps.scrada_send_9925.outputs.external_reference }}
          PASS9925_VAT_VARIANT: ${{ steps.scrada_send_9925.outputs.vat_variant }}
          PASS9925_ARCHIVE_DRIVER: ${{ steps.scrada_status_9925.outputs.archive_driver }}
          PASS9925_ARCHIVE_LOCATION: ${{ steps.scrada_status_9925.outputs.archive_location }}
          PASS9925_ARCHIVE_KEY: ${{ steps.scrada_status_9925.outputs.archive_key }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const fs = require("fs/promises");
          const path = require("path");
          const { promisify } = require("util");
          const { execFile } = require("child_process");
          const execFileAsync = promisify(execFile);

          async function pathExists(targetPath) {
            try {
              await fs.access(targetPath);
              return true;
            } catch {
              return false;
            }
          }

          async function readJsonIfExists(filePath) {
            if (!(await pathExists(filePath))) {
              return null;
            }
            const text = await fs.readFile(filePath, "utf8");
            try {
              return JSON.parse(text);
            } catch {
              return null;
            }
          }

          async function readLines(filePath) {
            if (!(await pathExists(filePath))) {
              return [];
            }
            const text = await fs.readFile(filePath, "utf8");
            return text
              .split(/\r?\n/)
              .map((line) => line.trim())
              .filter((line) => line.length > 0);
          }

          async function readErrorPreview(filePath, limit) {
            if (!(await pathExists(filePath))) {
              return [];
            }
            const text = await fs.readFile(filePath, "utf8");
            const rawLines = text.split(/\r?\n/);
            const preview = [];
            for (let i = 0; i < rawLines.length; i += 1) {
              const raw = rawLines[i];
              preview.push(raw.length > 0 ? raw : "(blank line)");
              if (preview.length >= limit) {
                break;
              }
            }
            return preview;
          }

          async function collectExistingPaths(root, items) {
            const results = [];
            for (const relative of items) {
              const target = path.join(root, relative);
              if (await pathExists(target)) {
                results.push(path.relative(process.cwd(), target));
              }
            }
            if (results.length === 0 && (await pathExists(root))) {
              const names = await fs.readdir(root);
              names.sort((a, b) => a.localeCompare(b, "en"));
              for (const name of names) {
                results.push(path.relative(process.cwd(), path.join(root, name)));
              }
            }
            return results;
          }

          (async () => {
            const repoRoot = process.cwd();
            const outputDir = path.join(repoRoot, "output");
            await fs.mkdir(outputDir, { recursive: true });

            const runId = process.env.GITHUB_RUN_ID ?? "unknown";
            const repository = process.env.GITHUB_REPOSITORY ?? "";
            const fallbackRunUrl = repository
              ? `https://github.com/${repository}/actions/runs/${runId}`
              : `actions/runs/${runId}`;
            const runUrl = process.env.RUN_URL || fallbackRunUrl;
            const sha = process.env.GITHUB_SHA ?? "unknown";
            const isolation = process.env.ISOLATION_RESULT ?? "Isolation=UNKNOWN";
            const adapterLine = process.env.ADAPTER_CHECK ?? "";

            const passes = [
              { id: "0208", envPrefix: "PASS0208" },
              { id: "9925", envPrefix: "PASS9925" }
            ];

            const headerLines = [];
            const passSummaries = [];

            for (const pass of passes) {
              const artifactDir = path.join(repoRoot, "artifacts", "scrada", pass.id);
              const summary = {
                id: pass.id,
                statusEnv: process.env[`${pass.envPrefix}_STATUS`] ?? "",
                channelEnv: process.env[`${pass.envPrefix}_CHANNEL`] ?? "",
                documentId: process.env[`${pass.envPrefix}_DOCUMENT_ID`] ?? "",
                archiveDriver: process.env[`${pass.envPrefix}_ARCHIVE_DRIVER`] ?? "",
                archiveLocation: process.env[`${pass.envPrefix}_ARCHIVE_LOCATION`] ?? "",
                archiveKey: process.env[`${pass.envPrefix}_ARCHIVE_KEY`] ?? "",
                artifactPaths: [],
                errorPreview: [],
                statusText: "unknown",
                channelText: "unknown",
                supportBundlePath: "",
                supportBundleError: "",
                statusCode: null
              };

              summary.statusText = summary.statusEnv || "unknown";
              summary.channelText = summary.channelEnv || "unknown";

              if (await pathExists(artifactDir)) {
                const sendData = await readJsonIfExists(path.join(artifactDir, "scrada-send-output.json"));
                const attempts = Array.isArray(sendData?.attempts) ? sendData.attempts : [];
                const lastAttempt = attempts.length > 0 ? attempts[attempts.length - 1] : null;

                if (summary.channelText === "unknown" && typeof sendData?.channel === "string") {
                  summary.channelText = sendData.channel;
                } else if (summary.channelText === "unknown" && lastAttempt?.channel) {
                  summary.channelText = lastAttempt.channel;
                }

                if (lastAttempt && typeof lastAttempt.statusCode === "number") {
                  summary.statusCode = lastAttempt.statusCode;
                  if (summary.statusCode === 400) {
                    summary.statusText = "HTTP 400";
                  } else if (summary.statusText === "unknown") {
                    summary.statusText = `HTTP ${summary.statusCode}`;
                  }
                }

                if (headerLines.length === 0) {
                  const headersPath = path.join(artifactDir, "headers-sent.txt");
                  headerLines.push(...(await readLines(headersPath)));
                }

                summary.errorPreview = await readErrorPreview(
                  path.join(artifactDir, "error-body.txt"),
                  2
                );

                summary.artifactPaths = await collectExistingPaths(artifactDir, [
                  "json-sent.json",
                  "ubl-sent.xml",
                  "headers-sent.txt",
                  "error-body.txt",
                  "scrada-send-output.log",
                  "scrada-send-output.json",
                  "scrada-status-output.json",
                  "participant.json"
                ]);

                const needsSupportBundle =
                  summary.statusCode === 400 || summary.statusText === "HTTP 400";
                if (needsSupportBundle) {
                  const zipName = `scrada_support_bundle_${pass.id}_${runId}.zip`;
                  const zipPath = path.join(outputDir, zipName);
                  try {
                    await fs.unlink(zipPath).catch(() => {});
                    await execFileAsync("zip", ["-r", zipPath, "."], { cwd: artifactDir });
                    summary.supportBundlePath = path.relative(repoRoot, zipPath);
                    console.log(`Support bundle created: ${summary.supportBundlePath}`);
                  } catch (zipError) {
                    summary.supportBundleError =
                      zipError && zipError.message ? zipError.message : String(zipError ?? "unknown error");
                    console.error(
                      `Failed to create support bundle for pass ${pass.id}: ${summary.supportBundleError}`
                    );
                  }
                }
              }

              passSummaries.push(summary);
            }

            const summaryLines = [];
            summaryLines.push("# Summary");
            summaryLines.push(`- Run URL: ${runUrl}`);
            summaryLines.push(`- SHA: ${sha}`);
            if (adapterLine) {
              summaryLines.push(`- ${adapterLine}`);
            }
            summaryLines.push(`- Isolation: ${isolation}`);

            const appendBlankLine = () => {
              if (summaryLines.length === 0) {
                return;
              }
              if (summaryLines[summaryLines.length - 1] === "") {
                return;
              }
              summaryLines.push("");
            };

            appendBlankLine();
            summaryLines.push("## Header values");
            if (headerLines.length > 0) {
              for (const line of headerLines) {
                summaryLines.push(`- ${line}`);
              }
            } else {
              summaryLines.push("- (no UBL header preview captured)");
            }

            for (const summary of passSummaries) {
              appendBlankLine();
              summaryLines.push(`## Pass ${summary.id}`);
              summaryLines.push(`- Channel: ${summary.channelText}`);
              summaryLines.push(`- Final status: ${summary.statusText}`);
              if (summary.documentId) {
                summaryLines.push(`- Document ID: ${summary.documentId}`);
              }
              if (summary.artifactPaths.length > 0) {
                summaryLines.push(`- Artifacts: ${summary.artifactPaths.join("; ")}`);
              }
              if (
                summary.archiveDriver ||
                summary.archiveLocation ||
                summary.archiveKey
              ) {
                const archiveParts = [
                  summary.archiveDriver,
                  summary.archiveLocation,
                  summary.archiveKey
                ].filter(Boolean);
                summaryLines.push(`- Archive: ${archiveParts.join(" | ")}`);
              }
              if (summary.errorPreview.length > 0) {
                summaryLines.push("- Error preview:");
                for (const line of summary.errorPreview) {
                  summaryLines.push(`  - ${line}`);
                }
              }
              if (summary.supportBundlePath) {
                summaryLines.push(`- Support bundle: ${summary.supportBundlePath}`);
              } else if (summary.supportBundleError) {
                summaryLines.push(`- Support bundle: failed (${summary.supportBundleError})`);
              }
            }

            appendBlankLine();
            const summaryPath = path.join(outputDir, "scrada_run_summary.md");
            await fs.writeFile(summaryPath, `${summaryLines.join("\n")}\n`, "utf8");
            console.log(`Summary written to ${path.relative(repoRoot, summaryPath)}`);
          })().catch((error) => {
            console.error(error);
            process.exit(1);
          });
          NODE
          cat output/scrada_run_summary.md

      - name: Upload Scrada artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: scrada-flow-artifacts
          if-no-files-found: warn
          path: |
            artifacts/scrada/0208
            artifacts/scrada/9925
            output/scrada_run_summary.md
            ${{ format('output/scrada_support_bundle_0208_{0}.zip', github.run_id) }}
            ${{ format('output/scrada_support_bundle_9925_{0}.zip', github.run_id) }}
            ${{ steps.scrada_send_0208.outputs.document_id && format('.data/archive/peppol/{0}.xml', steps.scrada_send_0208.outputs.document_id) }}
            ${{ steps.scrada_send_9925.outputs.document_id && format('.data/archive/peppol/{0}.xml', steps.scrada_send_9925.outputs.document_id) }}
